library(shiny); runApp('App_KERAS.R')
runApp('App_KERAS.R')
runApp('App_KERAS.R')
runApp('App_KERAS.R')
runApp('App_KERAS.R')
reticulate::use_virtualenv("cnn_env", required = TRUE)
# Ejecuta un comando de Python para importar el paquete y ver su versi贸n
reticulate::py_run_string("import tensorflow as tf; print(tf.__version__)")
runApp('App_KERAS.R')
reticulate::use_virtualenv("cnn_env", required = TRUE)
# Ejecuta un comando de Python para importar el paquete y ver su versi贸n
reticulate::py_run_string("import keras3 as tf; print(tf.__version__)")
reticulate::use_virtualenv("cnn_env", required = TRUE)
# Ejecuta un comando de Python para importar el paquete y ver su versi贸n
reticulate::py_run_string("import keras as tf; print(tf.__version__)")
reticulate::use_virtualenv("cnn_env", required = TRUE)
# Ejecuta un comando de Python para importar el paquete y ver su versi贸n
reticulate::py_run_string("import numpy as tf; print(tf.__version__)")
runApp('App_KERAS.R')
rsconnect::deployApp(
appFiles = c("App_KERAS.R", ".Rprofile", "requirements.txt", "runtime.txt", "model.keras"),
appName = "test",
account = "omicsperulab",
forceUpdate = TRUE  # Este argumento fuerza el redespliegue total
)
rlang::last_trace()
rsconnect::deployApp(
appFiles = c("App_KERAS.R", ".Rprofile", "requirements.txt", "runtime.txt", "model.keras"),
appName = "test",
account = "omicsperulab",
forceUpdate = TRUE  ,
appMode = "shiny")
rsconnect::deployApp(
appFiles = c("App_KERAS.R", ".Rprofile", "requirements.txt", "runtime.txt", "model.keras"),
appName = "test",
account = "omicsperulab",
forceUpdate = TRUE  ,
appMode = "shiny")
library(reticulate)
virtualenv_create("cnn_env")
use_virtualenv("cnn_env", required = TRUE)
py_install("tensorflow", envname = "cnn_env")
py_install("tflite-runtime")
library(shiny); runApp('App_KERAS.R')
runApp('App_KERAS.R')
interpreter <- tflite_runtime$Interpreter(model_path = "unet_model.tflite")
runApp('App_KERAS.R')
runApp('App_KERAS.R')
scale_factor <- 1000 / input$px_per_1000um
wdir <- tempfile("run_"); dir.create(wdir)
mask_dir <- file.path(wdir, "Predicted_masks"); dir.create(mask_dir)
overlay_dir <- file.path(wdir, "Predicted_overlays"); dir.create(overlay_dir)
workdir(wdir)
li <- tryCatch(
load_uploaded_images(input$imgs),
error = function(e) {
shiny::showNotification(paste("Error loading images:", e$message), type = "error")
return(NULL)
})
X <- li$images; fnames <- li$filenames
Xnp <- X
preds <- unet_model$predict(Xnp)
runApp('App_KERAS.R')
runApp('App_KERAS.R')
scale_factor <- 1000 / input$px_per_1000um
wdir <- tempfile("run_"); dir.create(wdir)
mask_dir <- file.path(wdir, "Predicted_masks"); dir.create(mask_dir)
overlay_dir <- file.path(wdir, "Predicted_overlays"); dir.create(overlay_dir)
workdir(wdir)
li <- tryCatch(
load_uploaded_images(input$imgs),
error = function(e) {
shiny::showNotification(paste("Error loading images:", e$message), type = "error")
return(NULL)
})
X <- li$images; fnames <- li$filenames
Xnp <- X
Sys.info()[['sysname']] == "Windows"
preds <- unet_model$predict(Xnp)
runApp('App_KERAS.R')
rsconnect::showLogs()
rsconnect::deployApp("App_KERAS.R")
rsconnect::deployApp("")
rsconnect::deployApp()
runApp('App_KERAS.R')
rsconnect::writeManifest()
rsconnect::deployApp()
options(rsconnect.http.timeout = 600)
rsconnect::deployApp()
